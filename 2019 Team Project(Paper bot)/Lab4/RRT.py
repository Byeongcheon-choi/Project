#!python3

import math
import matplotlib.pyplot as plt
from matplotlib import colors
import matplotlib.patches as patches
import numpy as np
import random
import copy
import time
W = 500 #mm
L = 750 #mm
maxTurnSpeed = 2.39 #rad/sec
maxMoveSpeedF = 102 #mm/sec
maxMoveSpeedB = 102 #mm/sec
carRadius = 95/2 #mm

#Problem 2.2a
#Create a visualization of the map with inital state and goal
def plotCSpace(obstacleList, edges=[], vertices=[], path=[], plotTitle='RRT Algorithm'):
    fig, ax = plt.subplots()
    ax.set_title(plotTitle)
    ax.set_xlim([0, W])
    ax.set_ylim([0, L])
    ax.set_xticks(np.arange(0, W, 100))
    ax.set_yticks(np.arange(0, L, 100))
    ax.set_aspect('equal')
    ax.set_title(plotTitle)
    # Draw the obstacles
    for obstacle in obstacleList:
        width = obstacle[1][0] - obstacle[0][0]
        height = obstacle[1][1] - obstacle[0][1]
        rect = patches.Rectangle(obstacle[0], width, height,linewidth=1,edgecolor='black',facecolor='green')
        ax.add_patch(rect)
    # Draw the vertices
    for vert in vertices:
        ax.add_artist(plt.Circle((vert[0], vert[1]), 2, color='black'))
    # Draw the edges
    for edge in edges:
        dx = edge[1][0] - edge[0][0]
        dy = edge[1][1] - edge[0][1]
        if (dx != 0 or dy != 0):
            plt.arrow(edge[0][0], edge[0][1], dx, dy, head_width=0, linewidth=0.5, length_includes_head=True, color='black')
    # Draw the path
    if path is not None:
        for x in range(len(path)):
            vert = path[x]
            radius = 2
            if(x == 0 or x == len(path) - 1):
                radius = 4
            ax.add_artist(plt.Circle((vert[0], vert[1]), radius, color='red'))
            if x < len(path) - 1:
                #print(path)
                dx = path[x+1][0] - vert[0]
                dy = path[x+1][1] - vert[1]
                if (dx != 0 or dy != 0):
                    plt.arrow(vert[0], vert[1], dx, dy, head_width=0, linewidth=0.5, length_includes_head=True, color='red')

    #print("Edges: " + str())
    plt.show()


#Problem 2.2a
#Returns a boolean if the specified point is valid for the robot to be located 
#i.e. robot is not in an obstacle or too close to the wall
def isValidPoint(x, y,obstacleList, theta=0):
    # First check if it's too close to a wall
    if x < carRadius or x > W - carRadius:
        return False
    if y < carRadius or y > L - carRadius:
        return False
    # Now check the obstacle list
    for obstacle in obstacleList:
        if x >= obstacle[0][0] - carRadius and x <= obstacle[1][0] + carRadius:
            if y <= obstacle[0][1] + carRadius and y >= obstacle[1][1] - carRadius:
                return False
    return True


#Problem 2.2b
#inputV is a 1D list of states to check against
#Everything is compared off of time to achieve that point
#(i.e. time to rotate + time to move)
#In the unlikely event that two points take equal time, the point that is farther on the Euclidean XY axis is returned
def getClosestPoint(inputVList, targetV):
    closePoint = None
    xTargetPosition = targetV[0]
    yTargetPosition = targetV[1]
    hTargetStatus = targetV[2]
    MaxDistance = float(0)
    minTime = float('inf')
    
    for point in inputVList:
        xPosition = point[0]
        yPosition = point[1]
        hStatus = point[2]
        x = abs(xTargetPosition - xPosition)
        y = abs(yTargetPosition - yPosition)
        sqrtx = x**2
        sqrty = y**2
        d = math.sqrt(sqrtx + sqrty)  #get the difference in distance
        deltaTheta = abs(hTargetStatus - hStatus)  #get angle 
        if deltaTheta > math.pi:                   #theta correction
            deltaTheta = 2*math.pi - deltaTheta
        timeRotate = deltaTheta/maxTurnSpeed   #get the time to rotate
        timeMoveForward = d/maxMoveSpeedF    #get time to move forward
        totalTime = timeRotate + timeMoveForward
        if totalTime < minTime:
            minTime = totalTime
            closePoint = point
        elif totalTime == minTime:
            minTime = totalTime
            if d > MaxDistance:
                maxDistance = d
                closePoint = point

    return closePoint


#Problem 2.2c
#Returns a point that is achievable and the input to get to that point
#The trajectory is generated by first having the robot turn and then having it move.
#The time taken for rotation and movement may not exceed one second
#The return value inputs[] is a tuple of 2 tuples in the format (leftMotor,RightMotor,timeTaken), 
#where the first tuple is for rotation and the second is for driving
#The return value trag is a a 2 element tuple of a start and end point (startV,acheivableV)
def genAchievableTraj(startV, targetV):
    turnOnly = False
    inputs = []
    timeToRotate = 0
    newHeading = 0

    #check rotation
    if (targetV[0] > startV[0]):
        alignmentRotation = (math.pi/2) - math.atan((targetV[1] - startV[1])/((targetV[0] - startV[0])))
    elif (targetV[0] < startV[0]): 
        alignmentRotation = (3*math.pi/2) - math.atan((targetV[1] - startV[1])/((targetV[0] - startV[0])))
    elif (targetV[0] == startV[0] and targetV[1] == startV[1]):
        alignmentRotation = targetV[2]
    else:
        alignmentRotation = startV[2]

    if (startV[2] != alignmentRotation):
    #        rotationDiff = abs(startV[2] - targetV[2])
        rotationDiff = abs(alignmentRotation - startV[2])
        turnOtherWay = False
        if alignmentRotation < startV[2]: #gamma smaller than theta
            turnOtherWay = True

        if ( (rotationDiff < math.pi and not turnOtherWay) or (rotationDiff > math.pi and turnOtherWay)):
            #Need to turn CW
            #print("CW turn")
            turnOnly = False
            if not turnOtherWay:
                timeToRotate = rotationDiff/maxTurnSpeed
                if (timeToRotate >= 1 or (startV[1] == targetV[1] and startV[0] == targetV[0])):
                    turnOnly = True
                    if (timeToRotate >= 1):
                        timeToRotate = 1
                newHeading = (startV[2] + maxTurnSpeed * timeToRotate)%(2*math.pi) #make sure there is no overflow
                # print("New heading: " + str(newHeading))
                # print("Goal heading: " + str(alignmentRotation))
                # print("Rotation Time: " + str(timeToRotate))
                # print("Rotation Difference: " + str(rotationDiff))

            else:
                timeToRotate = ((2 * math.pi )- rotationDiff)/maxTurnSpeed
                if (timeToRotate >= 1  or (startV[1] == targetV[1] and startV[0] == targetV[0])):
                    turnOnly = True
                    if (timeToRotate >= 1):
                        timeToRotate = 1
                newHeading = (startV[2] + maxTurnSpeed * timeToRotate + (2 * math.pi))%(2*math.pi) #make sure there is no overflow

            if (turnOnly): #we're only turning this time
                timeToRotate = 1
                achV = (startV[0],startV[1],newHeading)
            inputs.append((0,180,timeToRotate))
        else:
            #Need to turn CCW
            #print("CCW turn")
            turnOnly = False
            if turnOtherWay:
                timeToRotate = rotationDiff/maxTurnSpeed
                if (timeToRotate >= 1 or (startV[1] == targetV[1] and startV[0] == targetV[0])):
                    turnOnly = True
                    if (timeToRotate >= 1):
                        timeToRotate = 1
                newHeading = (startV[2] - maxTurnSpeed * timeToRotate +(2*math.pi))%(2*math.pi) #add 2PI and then do mod to make sure the value isn't negative

            else:
                timeToRotate = ((2 * math.pi )- rotationDiff)/maxTurnSpeed
                if (timeToRotate >= 1 or (startV[1] == targetV[1] and startV[0] == targetV[0])):
                    turnOnly = True
                    if (timeToRotate >= 1):
                        timeToRotate = 1
                newHeading = (startV[2] - maxTurnSpeed * timeToRotate +(2*math.pi))%(2*math.pi) #add 2PI and then do mod to make sure the value isn't negative
            if (turnOnly):
                achV = (startV[0],startV[1], newHeading)
            inputs.append((180,0,timeToRotate))
    else:
        #no turning is necessary
        newHeading = startV[2]
    if (timeToRotate != 1):
        #Verify that there aren't any issues with float rounding (i.e. check to see if values are close enough)
        angleDiff = abs(newHeading - alignmentRotation)
        # if (newHeading != alignmentRotation and angleDiff > (0.01 * newHeading)):
        #     print("ERROR: NOT ALIGNED")
        #     print(newHeading)
        #     print(alignmentRotation)
        # else:
        #     print("Success")
        #Still need to try to move forward
        timeToDrive = 0
        distanceToTarget = math.sqrt((startV[0] - targetV[0])**2 + (startV[1] - targetV[1])**2)
        distanceDriving = (1-timeToRotate)*maxMoveSpeedF
        newX = 0
        newY = 0
        if distanceToTarget > distanceDriving:
            #target is farther than we can drive to
            timeToDrive = 1 - timeToRotate
            newX = (math.sin(newHeading) * distanceDriving) + startV[0]
            newY = (math.cos(newHeading) * distanceDriving) + startV[1]
        elif distanceToTarget < distanceDriving:
            #target is within driving range
            timeToDrive = distanceToTarget / maxMoveSpeedF
            newX = targetV[0]
            newY = targetV[1]
        else:
            #the unlikely event that the target is exactly at driving length
            timeToDrive = 1 - timeToRotate
            newX = targetV[0]
            newY = targetV[1]
        achV = (newX, newY, newHeading)
        inputs.append((180, 150, timeToDrive))


    return ((startV,achV),inputs)


#Problem 2.2d
#Returns True if the trajectory is collision free
def isCollisionFree(trajectory, obstacleList):
    minDistance = float("inf")
    for obstacle in obstacleList:
        edgeSegs = []
        #Define corners of obstacle
        topLeft = obstacle[0]
        botRight = obstacle[1]
        topRight = (obstacle[1][0],obstacle[0][1])
        botLeft = (obstacle[0][0],obstacle[1][1])
        edgeSegs.append((topLeft,topRight)) #add top edge
        edgeSegs.append((botLeft,botRight)) #add bottom edge
        edgeSegs.append((topLeft,botLeft)) #add left edge
        #print("Left Wall: " + str((topLeft,botLeft)))
        edgeSegs.append((topRight,botRight)) #add right edge

        for edge in edgeSegs:
            distance = distBetweenSegments(edge,trajectory,.5)
            if distance < minDistance:
                minDistance = distance
        #print(edgeSegs)
    if minDistance <= carRadius:
        #print(minDistance)
        #print("REJECTED")
        return False
    elif isValidPoint(trajectory[1][0], trajectory[1][1], obstacleList) is False:  # make sure endpoint not in obstacle
        return False
    else:
        return True


#Helper function to calculate the distance between two and line segments
#Input values seg1 and seg2 are tuples of two elements that contain points
# The input value delta determines the step size for decomposing the segments into points
# Note: Only does checks at integer values
def distBetweenSegments(seg1, seg2,delta):

    #Decompose seg1 into points
    xVals1 = floatRange(seg1[0][0],seg1[1][0], delta)
    yVals1 = floatRange(seg1[0][1],seg1[1][1], delta)
    if (len(xVals1) == 1): #only the size of one
        for x in range(len(yVals1) - 1):
            xVals1.append(xVals1[0])
    elif(len(yVals1) == 1):
        for x in range(len(xVals1) - 1):
            yVals1.append(yVals1[0])
    points1 = list(zip(xVals1,yVals1))

    #Decompose seg2 into points
    xVals2 = floatRange(seg2[0][0],seg2[1][0], delta)
    yVals2 = floatRange(seg2[0][1],seg2[1][1], delta)

    if (len(xVals2) == 1): #only the size of one
        for x in range(len(yVals2) - 1):
            xVals2.append(xVals2[0])
    elif(len(yVals2) == 1):
        for x in range(len(xVals2) - 1):
            yVals2.append(yVals2[0])
    points2 = list(zip(xVals2,yVals2))
    """if (xVals2[0] == 50 and yVals2[0] == 50):
        print(points2)
    if (xVals1[0] == 50 and yVals1[0] == 50):
        print(points1)"""


    """if (len(points1) == 1):
        print("P1 issue")
    if (len(points2) == 1):
        print("P2 issue")
        print(len(xVals2))
        print(len(yVals2))
        print("segment:")
        print(seg2)
    print(len(points1))
    print(len(points2))"""

    minDist = float("inf")
    for p1 in points1:
        for p2 in points2:
            dist = math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)
            if dist < minDist:
                minDist = dist
    return minDist

#Helper function to generate a range of floats values
#end is appended to the end of the list
def floatRange(start,end,step):
    if (start > end):
        temp = end
        end = start
        start = temp

    floatList = []
    i = start
    while (i < end):
        floatList.append(i)
        i = i + step
    floatList.append(i)
    #print(floatList)
    if (len(floatList) == 1):
        """print("issue")
        print(floatList)
        print(start)
        print(end)"""
    return floatList

#Problem 2.2e
#Run the RRT planner
def RRTPlanner(initialState,targetState,obstacleList, pointsToCheck=1000):
    vertices = []
    vertices.append(initialState)
    edges = []
    time1 = int(round(time.time() * 1000))
    subtime1 = 0
    subtime2 = 0
    subtime3 = 0
    subtime4 = 0
    for x in range(1,pointsToCheck):
        #generate random point
        start = int(round(time.time() * 1000))
        randX = random.uniform(0,W)
        randY = random.uniform(0,L)
        randH = random.random() * 2 * math.pi
        randPoint = (randX,randY,randH)
        generation = int(round(time.time() * 1000))
        subtime1 = subtime1 + (generation - start)
        # if(x == 1000 or x == 5000):
        #     title = 'RRT Algorithm After ' + str(x) + ' Iterations'
        #     plotCSpace(obstacleList,edges,vertices, plotTitle=title)

        if  isValidPoint(randX,randY,obstacleList):
            xnearest = getClosestPoint(vertices,randPoint)
            verification = int(round(time.time() * 1000))
            subtime2 = subtime2 + (verification - generation)
            traj,inputs = genAchievableTraj(xnearest,randPoint)
            trajTime = int(round(time.time() * 1000))
            subtime3 = subtime3 + (trajTime - verification)
            if (isCollisionFree(traj,obstacleList)):
                vertices.append(traj[1])
                edges.append(traj)
                checkCollisions = int(round(time.time() * 1000))
                subtime4 = subtime4 + (checkCollisions - trajTime)

    time2 = int(round(time.time() * 1000))
    closeToTarget = getClosestPoint(vertices,targetState)
    edgePath = findPath(closeToTarget, initialState,edges)
    #Need to reverse path since the current path is from the goal to the starting point
    edgePath = list(reversed(edgePath))

    if edgePath is None:
        print("NO PATH FOUND")

    #Reformat the path to be an edge path instead of a point path
    path = []
    for edge in edgePath:
        path.append(edge[0])

    if edgePath != []:
        path.append(edgePath[-1][1])

    time3 = int(round(time.time() * 1000))
    # print("Edges: " + str(edges))
    # print("Edge path: " + str(edgePath))
    print("--------------")
    print(str(time2-time1))
    print(str(time3-time2))
    print(subtime1)
    print(subtime2)
    print(subtime3)
    print(subtime4)
    print("--------------")

    return (vertices,edges,path)


#Problem 2.2f
#Run the RRT planner in reverse (i.e. build tree from targetState to initialState)
def reverseRRTPlanner(initialState,targetState,obstacleList, pointsToCheck=1500):
    vertices = []
    vertices.append(targetState)
    edges = []
    time1 = int(round(time.time() * 1000))
    subtime1 = 0
    subtime2 = 0
    subtime3 = 0
    subtime4 = 0
    for x in range(1,pointsToCheck):
        #generate random point
        start = int(round(time.time() * 1000))
        randX = random.uniform(0,W)
        randY = random.uniform(0,L)
        randH = random.random() * 2 * math.pi
        randPoint = (randX,randY,randH)
        generation = int(round(time.time() * 1000))
        subtime1 = subtime1 + (generation - start)
        # if(x == 1000 or x == 5000):
        #     title = 'RRT Algorithm After ' + str(x) + ' Iterations'
        #     plotCSpace(obstacleList,edges,vertices, plotTitle=title)

        if  isValidPoint(randX,randY,obstacleList):
            xnearest = getClosestPoint(vertices,randPoint)
            verification = int(round(time.time() * 1000))
            subtime2 = subtime2 + (verification - generation)
            traj,inputs = genAchievableTraj(xnearest,randPoint)
            trajTime = int(round(time.time() * 1000))
            subtime3 = subtime3 + (trajTime - verification)
            if (isCollisionFree(traj,obstacleList)):
                vertices.append(traj[1])
                edges.append(traj)
                checkCollisions = int(round(time.time() * 1000))
                subtime4 = subtime4 + (checkCollisions - trajTime)

    time2 = int(round(time.time() * 1000))
    closeToTarget = getClosestPoint(vertices,initialState)
    edgePath = findPath(closeToTarget, targetState,edges)
    #Need to reverse path since the current path is from the goal to the starting point
    edgePath = list(reversed(edgePath))

    if edgePath is None:
        print("NO PATH FOUND")

    #Reformat the path to be an edge path instead of a point path
    path = []
    for edge in edgePath:
        path.append(edge[0])

    if edgePath != []:
        path.append(edgePath[-1][1])

    time3 = int(round(time.time() * 1000))
    # print("Edges: " + str(edges))
    # print("Edge path: " + str(edgePath))
    print("--------------")
    print(str(time2-time1))
    print(str(time3-time2))
    print(subtime1)
    print(subtime2)
    print(subtime3)
    print(subtime4)
    print("--------------")

    return (vertices,edges,path)


#Recursive helper method to determine the path to navigate from one point to another in a tree
#It is assumed that the starting and target points are located on the tree
#None is returned if there is no path. An edge path is returned otherwise
def findPath(startingPoint, targetPoint, edges, currentPath=[]):
    print(len(currentPath))
    if (startingPoint == targetPoint):
        return currentPath
    elif currentPath is not None:
        #Find the edges that contain the starting point and recursively iterate
        for edge in edges:
            newPath = copy.deepcopy(currentPath)
            if (edge[0] == startingPoint and edge not in currentPath):
                newPath.append(edge)
                result = findPath(edge[1],targetPoint,edges,newPath)
                if result is not None:#We found a path; otherwise let it keep trying other edges
                    return result

            if (edge[1] == startingPoint and edge not in currentPath):
                newPath.append(edge)
                result = findPath(edge[0],targetPoint,edges,newPath)
                if result is not None:#We found a path; otherwise let it keep trying other edges
                    return result
    return None


